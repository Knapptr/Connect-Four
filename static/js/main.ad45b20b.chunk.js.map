{"version":3,"sources":["components/styles/wrappers.tsx","components/Header.tsx","game/events.ts","game/board.ts","game/player.ts","game/game.ts","game/app.ts","components/styles/components.ts","components/Players.tsx","components/Column.tsx","components/Board.tsx","components/game.tsx","components/styles/global.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["HeaderWrapper","styled","header","PlayersWrapper","ul","BoardWrapper","div","ColumnWrapper","GameWrapper","Header","href","rel","target","EventsManager","events","add","eventName","callback","push","remove","filter","cb","trigger","data","action","forEach","fn","payload","CreateBoard","width","height","Error","board","Array","from","_colVal","xIndex","_rowVal","yIndex","coords","x","y","occupied","checkIfColFull","index","every","cell","checkForFour","arr","consecutive","compareElement","currentIndex","isFour","length","currentElement","getHorizontalArrays","invertedArray","col","cellInRow","createBottomToTopDiagonalArrayFromIndex","indexCell","returnArray","createTopToBottomDiagonalArrayFromIndex","checkDiagonalLBtoTR","allDiagonals","column","slice","relevantCell","diag","createDiagonalsBottomToTop","some","d","checkDiagonalRBtoTL","createDiagonalsTopToBottom","getBoard","placePiece","playerID","rowIndex","lastSpace","findIndex","findLowestAvailableRow","checkForFourInRow","row","checkIfFilled","CreatePlayer","player","name","id","isAI","color","getName","setName","newName","trimmedName","trim","getColor","setColor","newColor","CreateGame","playerInitData","boardSize","eventManager","gameOver","endState","players","playerData","getPlayers","playerList","getPlayerNames","names","turnCount","currentTurnIndex","isGameOver","getCurrentPlayer","getEndState","takeTurn","currentPlayerID","setPlayerNames","playerNames","playerIndex","getTurnCount","getPlayerColorByID","p","resetGame","defaultPlayers","defaultSize","connectFour","size","Cell","PlayerInfo","li","isCurrentPlayer","isWinner","Players","currentPlayer","winner","useState","setPlayers","console","log","useEffect","updatePlayers","map","onClick","Column","props","children","Board","setBoard","updateBoard","Game","setIsGameOver","setEndState","setCurrentPlayer","updatePlayer","updateGameOver","updateGameEnd","toUpperCase","GlobalStyle","createGlobalStyle","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ad45b20b.chunk.js","sourcesContent":["import styled from \"styled-components\";\n\nexport const HeaderWrapper = styled.header`\n  display: flex;\n  justify-content: space-around;\n  align-items: baseline;\n  padding: 2rem;\n  max-width: 800px;\n  margin: 0 auto;\n  h1 {\n    flex-grow: 1;\n  }\n  @media only screen and (max-width: 420px) {\n    padding: 0.5rem;\n    flex-direction: column;\n    align-items: center;\n    h1 {\n      font-size: 1.5rem;\n    }\n  }\n`;\n\nexport const PlayersWrapper = styled.ul`\n  display: flex;\n  flex-wrap: wrap;\n  gap: 0.25rem;\n  margin: 0;\n  justify-content: center;\n  align-items: stretch;\n  padding-inline-start: 0;\n  padding-inline-end: 0;\n  li {\n    padding: 1.5rem;\n  }\n`;\n\nexport const BoardWrapper = styled.div`\n  display: flex;\n  justify-content: center;\n  margin: 0 auto;\n  flex-grow: 1;\n  gap: 0.25rem;\n`;\n\ninterface ColProps {\n  onClick: (e: Event) => void;\n}\nexport const ColumnWrapper = styled.div<ColProps>`\n  display: flex;\n  gap: inherit;\n  flex-direction: column;\n  :hover {\n    filter: brightness(97%);\n  }\n`;\nexport const GameWrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  width: 85%;\n  max-width: 700px;\n  margin: 0 auto;\n  h1 {\n    text-align: center;\n  }\n`;\n","import { HeaderWrapper } from \"./styles/wrappers\";\nconst Header = () => {\n  return (\n    <HeaderWrapper>\n      <h1>(de)Connect Four</h1>\n      <a\n        href=\"https://github.com/knapptr/Connect-Four\"\n        rel=\"noreferrer\"\n        target=\"_blank\">\n        Github\n      </a>\n    </HeaderWrapper>\n  );\n};\n\nexport default Header;\n","import { Adder, Remover, Trigger, Events } from \"./types\";\nexport const EventsManager = () => {\n  const events: Events = {};\n\n  const add: Adder = (eventName, callback) => {\n    if (!events[eventName]) {\n      events[eventName] = [];\n    }\n    events[eventName].push(callback);\n  };\n\n  const remove: Remover = (eventName, callback) => {\n    if (events[eventName]) {\n      events[eventName] = events[eventName].filter((cb) => cb !== callback);\n    }\n  };\n  const trigger: Trigger = (data) => {\n    if (events[data.action]) {\n      events[data.action].forEach((fn) => {\n        fn(data.payload);\n      });\n    }\n  };\n  return {\n    add,\n    remove,\n    trigger,\n  };\n};\n\nexport default EventsManager;\n","import { BoardInit, Cell, PlayerID } from \"./types\";\n\nconst CreateBoard = (width: number, height: number) => {\n  if (width < 4 || height < 4) {\n    throw new Error(\"Height and width must each be greater than 0\");\n  }\n\n  const board: BoardInit = Array.from(Array(width), (_colVal, xIndex: number) =>\n    Array.from(\n      Array(height),\n      (_rowVal, yIndex: number): Cell => ({\n        coords: { x: xIndex, y: yIndex },\n        occupied: false,\n      })\n    )\n  );\n\n  const checkIfColFull = (index: number) => {\n    return board[index].every((cell) => cell.occupied);\n  };\n\n  const findLowestAvailableRow = (col: number) => {\n    const lastSpace = board[col].length - 1;\n    if (!board[col][lastSpace].occupied) return lastSpace;\n    const firstAvailable =\n      board[col].findIndex((cell) => cell.occupied !== false) - 1;\n    return firstAvailable;\n  };\n\n  const placePiece = (col: number, playerID: PlayerID): void => {\n    // check if full, throw if full\n    if (checkIfColFull(col)) {\n      throw new Error(\"Column is full!\");\n    }\n    // place piece in 'lowest' space\n    const rowIndex = findLowestAvailableRow(col);\n    board[col][rowIndex].occupied = playerID;\n  };\n\n  const checkIfFilled = () => {\n    return board.every((col) => col.every((cell) => cell.occupied));\n  };\n  const checkForFour = (arr: Cell[]) => {\n    // Analyzes an array, and checks if 4 cells in a row in the array are equal\n    let consecutive = 1;\n    let compareElement: string = arr[0].occupied || \"none\";\n    let currentIndex = 1;\n    let isFour = false;\n\n    while (!isFour && currentIndex < arr.length) {\n      let currentElement = arr[currentIndex];\n      if (currentElement.occupied === compareElement) {\n        consecutive += 1;\n        if (consecutive >= 4) {\n          isFour = true;\n        }\n        currentIndex += 1;\n        continue;\n      } else {\n        compareElement = currentElement.occupied || \"none\";\n        currentIndex += 1;\n        consecutive = 1;\n      }\n    }\n    return isFour;\n  };\n\n  const checkVerticalSpaces = () => {\n    return board.some((col) => {\n      return checkForFour(col);\n    });\n  };\n\n  const checkHorizontalSpaces = () => {\n    let invertedBoard = getHorizontalArrays();\n    return invertedBoard.some((row) => {\n      return checkForFour(row);\n    });\n  };\n\n  const getHorizontalArrays = () => {\n    // inverts board array to be [rows[cols]]\n    let invertedArray: Cell[][] = Array.from(board[0], () => []);\n    board.forEach((col) => {\n      col.forEach((cellInRow) => {\n        invertedArray[cellInRow.coords.y][cellInRow.coords.x] = cellInRow;\n      });\n    });\n    return invertedArray;\n  };\n\n  const createBottomToTopDiagonalArrayFromIndex = (indexCell: Cell) => {\n    const returnArray = [];\n    let x = indexCell.coords.x;\n    let y = indexCell.coords.y;\n    while (x < board.length && y >= 0) {\n      returnArray.push(board[x][y]);\n      y -= 1;\n      x += 1;\n    }\n    return returnArray;\n  };\n\n  const createTopToBottomDiagonalArrayFromIndex = (indexCell: Cell): Cell[] => {\n    const returnArray = [];\n    let x = indexCell.coords.x;\n    let y = indexCell.coords.y;\n    while (x >= 0 && y >= 0) {\n      returnArray.push(board[x][y]);\n      y -= 1;\n      x -= 1;\n    }\n    return returnArray;\n  };\n\n  const createDiagonalsTopToBottom = (): Cell[][] => {\n    const allDiagonals = [];\n    // push all diagonals from last column\n    for (const cell of board[board.length - 1]) {\n      allDiagonals.push(createTopToBottomDiagonalArrayFromIndex(cell));\n    }\n    // push all diagonals from first row except last col\n    for (const column of board.slice(0, board.length - 1)) {\n      const lastRowIndex = column.length - 1;\n      let relevantCell = column[lastRowIndex];\n      allDiagonals.push(createTopToBottomDiagonalArrayFromIndex(relevantCell));\n    }\n    //filter only diagonal 'rows' with at least 4\n    const relevantDiagonals = allDiagonals.filter((diag) => diag.length >= 4);\n    return relevantDiagonals;\n  };\n\n  const createDiagonalsBottomToTop = (): Cell[][] => {\n    const allDiagonals = [];\n    // push all diagonals from first column\n    for (const column of board[0]) {\n      allDiagonals.push(createBottomToTopDiagonalArrayFromIndex(column));\n    }\n    // push all diagonals from last row except first col\n    for (const column of board.slice(1)) {\n      const lastRowIndex = column.length - 1;\n      let relevantCell = column[lastRowIndex];\n      allDiagonals.push(createBottomToTopDiagonalArrayFromIndex(relevantCell));\n    }\n    //filter only diagonal 'rows' with at least 4\n    const relevantDiagonals = allDiagonals.filter((diag) => diag.length >= 4);\n    return relevantDiagonals;\n  };\n\n  const checkDiagonalLBtoTR = () => {\n    let diagonals = createDiagonalsBottomToTop();\n    return diagonals.some((d) => checkForFour(d));\n  };\n  const checkDiagonalRBtoTL = () => {\n    let diagonals = createDiagonalsTopToBottom();\n    return diagonals.some((d) => checkForFour(d));\n  };\n\n  const checkForFourInRow = () => {\n    // arrange in order of complexity- to get best performance\n    return (\n      checkVerticalSpaces() ||\n      checkHorizontalSpaces() ||\n      checkDiagonalLBtoTR() ||\n      checkDiagonalRBtoTL()\n    );\n  };\n  const getBoard = () => board;\n  return {\n    getBoard,\n    placePiece,\n    checkForFourInRow,\n    checkIfFilled,\n    checkIfColFull,\n  };\n};\n\nexport default CreateBoard;\n","import { PlayerInit } from \"./types\";\n\nconst CreatePlayer = (player: PlayerInit) => {\n  let name = player.name;\n  const id = player.id;\n  const isAI = player.isAI;\n  let color = player.color;\n\n  const getName = () => {\n    return name;\n  };\n  const setName = (newName: string) => {\n    let trimmedName = newName.trim();\n    if (trimmedName.length <= 0) {\n      trimmedName = \"anonymous\";\n    }\n    name = trimmedName;\n    return name;\n  };\n  const getColor = () => {\n    return color;\n  };\n  const setColor = (newColor: \"red\" | \"black\") => {\n    color = newColor;\n    return color;\n  };\n\n  return {\n    getName,\n    setName,\n    getColor,\n    setColor,\n    id,\n    isAI,\n  };\n};\nexport default CreatePlayer;\n","import CreateBoard from \"./board\";\nimport CreatePlayer from \"./player\";\nimport {\n  EventsManagerInterface,\n  GameBoard,\n  GamePlayer,\n  PlayerInit,\n} from \"./types\";\n\nconst CreateGame = (\n  playerInitData: PlayerInit[],\n  boardSize: number[],\n  eventManager: EventsManagerInterface\n) => {\n  let gameOver: boolean = false;\n  let endState: false | string = false;\n  const players: GamePlayer[] = Array.from(\n    playerInitData,\n    (playerData: PlayerInit) => CreatePlayer(playerData)\n  );\n\n  const getPlayers = () => {\n    const playerList: {\n      name: string;\n      id: string;\n      color: \"red\" | \"black\";\n    }[] = [];\n    players.forEach((player) => {\n      playerList.push({\n        name: player.getName(),\n        id: player.id,\n        color: player.getColor(),\n      });\n    });\n    return playerList;\n  };\n  const getPlayerNames = () => {\n    const names: string[] = [];\n    players.forEach((player) => {\n      names.push(player.getName());\n    });\n    return names;\n  };\n  const setPlayerNames = (playerNames: string[]) => {\n    players.forEach((player, playerIndex) => {\n      player.setName(playerNames[playerIndex]);\n    });\n    eventManager.trigger({ action: \"nameChange\", payload: getPlayerNames() });\n  };\n\n  let board: GameBoard = CreateBoard(boardSize[0], boardSize[1]);\n\n  const getBoard = () => {\n    return board.getBoard();\n  };\n\n  let turnCount = 0;\n\n  let currentTurnIndex = 0;\n\n  const advanceTurn = () => {\n    turnCount += 1;\n    currentTurnIndex += 1;\n    if (currentTurnIndex > players.length - 1) {\n      currentTurnIndex = 0;\n    }\n    eventManager.trigger({ action: \"turnChange\", payload: getCurrentPlayer() });\n  };\n  const isGameOver = () => {\n    if (board.checkForFourInRow()) {\n      gameOver = true;\n      endState = getCurrentPlayer().id;\n    } else {\n      if (board.checkIfFilled()) {\n        gameOver = true;\n        endState = \"tie\";\n      }\n    }\n    if (gameOver) {\n      eventManager.trigger({ action: \"gameEndChange\", payload: getEndState() });\n    }\n    return gameOver;\n  };\n\n  const getEndState = () => {\n    return endState;\n  };\n\n  const getCurrentPlayer = () => {\n    let player = players[currentTurnIndex];\n    let name = player.getName();\n    let id = player.id;\n    return {\n      name,\n      id,\n    };\n  };\n\n  const getTurnCount = () => {\n    return turnCount;\n  };\n\n  const getPlayerColorByID = (id: string) => {\n    let players = getPlayers();\n    let player = players.filter((p) => p.id === id)[0];\n    let color = player.color;\n    return color;\n  };\n  const takeTurn = (col: number) => {\n    if (board.checkIfColFull(col)) return;\n    if (gameOver) return;\n    let currentPlayerID = players[currentTurnIndex].id;\n    board.placePiece(col, currentPlayerID);\n    eventManager.trigger({ action: \"boardChange\", payload: board.getBoard() });\n    if (isGameOver()) {\n      // trigger game over, and send info for winning player\n      eventManager.trigger({ action: \"gameOver\", payload: true });\n      return;\n    }\n    advanceTurn();\n  };\n  const resetGame = () => {\n    board = CreateBoard(boardSize[0], boardSize[1]);\n    turnCount = 0;\n    gameOver = false;\n    endState = false;\n    eventManager.trigger({ action: \"boardChange\", payload: board.getBoard() });\n    eventManager.trigger({ action: \"gameEndChange\", payload: getEndState() });\n    eventManager.trigger({ action: \"turnChange\", payload: getCurrentPlayer() });\n    eventManager.trigger({ action: \"turnChange\", payload: getCurrentPlayer() });\n    eventManager.trigger({ action: \"gameOver\", payload: false });\n  };\n\n  return {\n    takeTurn,\n    getPlayers,\n    setPlayerNames,\n    getPlayerNames,\n    getTurnCount,\n    getCurrentPlayer,\n    isGameOver,\n    getBoard,\n    getPlayerColorByID,\n    getEndState,\n    resetGame,\n  };\n};\n\nexport default CreateGame;\n","import EventsManager from \"./events\";\nimport CreateGame from \"./game\";\nimport { PlayerInit } from \"./types\";\n\n/////defaultSettings\nconst defaultPlayers: PlayerInit[] = [\n  { name: \"Player 1\", id: \"player_1\", isAI: false, color: \"red\" },\n  { name: \"Player 2\", id: \"player_2\", isAI: false, color: \"black\" },\n];\nconst defaultSize = [7, 6];\n\nexport const events = EventsManager();\nconst connectFour = (players = defaultPlayers, size = defaultSize) => {\n  return CreateGame(players, size, events);\n};\n\nexport default connectFour();\n","import styled from \"styled-components\";\n\ninterface Props {\n  readonly occupied: boolean | string;\n  readonly color: \"red\" | \"black\" | \"white\";\n}\nexport const Cell = styled.div<Props>`\n  background: ${({ color }) => color};\n  max-width: 50px;\n  padding-bottom: 100%;\n  min-width: 28px;\n  border: 1px solid black;\n  @media only screen and (min-width: 444px) {\n    width: 50px;\n  }\n`;\nexport const PlayerInfo = styled.li<{\n  color: string;\n  isCurrentPlayer: boolean;\n  isWinner?: boolean;\n}>`\n  position: relative;\n  width: 100%;\n  background: ${({ color }) => color};\n  text-align: center;\n  color: whitesmoke;\n  list-style: none;\n  text-shadow: ${({ isCurrentPlayer }) =>\n    isCurrentPlayer ? \"0 0 5px white\" : \"none\"};\n  font-weight: bold;\n  padding: 1rem;\n  ::after {\n    content: ${({ isCurrentPlayer, isWinner }) =>\n      isWinner ? `\"🏆\"` : isCurrentPlayer ? `\"👍\"` : \"\"};\n    position: absolute;\n    padding-left: 15px;\n  }\n`;\n","import connectFour, { events } from \"../game/app\";\nimport { useState, useEffect } from \"react\";\nimport { Callback } from \"../game/types\";\nimport { PlayersWrapper } from \"./styles/wrappers\";\nimport { PlayerInfo } from \"./styles/components\";\nconst Players = ({\n  currentPlayer,\n  gameOver,\n  winner,\n}: {\n  winner?: string | false;\n  gameOver: boolean;\n  currentPlayer: { id: string; name: string };\n}) => {\n  const [players, setPlayers] = useState(connectFour.getPlayers());\n  console.log(gameOver);\n  //sub to players\n  useEffect(() => {\n    const updatePlayers: Callback = (data) => {\n      setPlayers(data as []);\n    };\n    events.add(\"nameChange\", updatePlayers);\n    //cleanup\n    return () => {\n      events.remove(\"nameChange\", updatePlayers);\n    };\n  }, []);\n\n  return (\n    <PlayersWrapper>\n      {gameOver\n        ? players.map((player) => (\n            <PlayerInfo\n              isWinner={winner === player.id}\n              isCurrentPlayer={currentPlayer.id === player.id}\n              color={connectFour.getPlayerColorByID(player.id)}\n              key={`PLAYER-${player.id}`}>\n              {player.name}\n            </PlayerInfo>\n          ))\n        : players.map((player) => (\n            <PlayerInfo\n              isCurrentPlayer={currentPlayer.id === player.id}\n              color={connectFour.getPlayerColorByID(player.id)}\n              key={`PLAYER-${player.id}`}>\n              {player.name}\n            </PlayerInfo>\n          ))}\n      {gameOver ? (\n        <button\n          onClick={() => {\n            connectFour.resetGame();\n          }}>\n          Play Again\n        </button>\n      ) : null}\n    </PlayersWrapper>\n  );\n};\n\nexport default Players;\n","import connectFour from \"../game/app\";\nimport { ColumnWrapper } from \"./styles/wrappers\";\n\nconst Column = (props: {\n  index: number;\n  children: JSX.Element | JSX.Element[];\n}) => {\n  return (\n    <ColumnWrapper onClick={() => connectFour.takeTurn(props.index)}>\n      {props.children}\n    </ColumnWrapper>\n  );\n};\n\nexport default Column;\n","import connectFour, { events } from \"../game/app\";\nimport { BoardWrapper } from \"./styles/wrappers\";\nimport { useEffect, useState } from \"react\";\nimport { BoardInit, Callback } from \"../game/types\";\nimport { Cell } from \"./styles/components\";\nimport Column from \"./Column\";\n\nconst Board = () => {\n  const [board, setBoard] = useState(connectFour.getBoard());\n\n  useEffect(() => {\n    const updateBoard: Callback = (data) => {\n      setBoard(data as BoardInit);\n    };\n    events.add(\"boardChange\", updateBoard);\n    return () => {\n      events.remove(\"boardChange\", updateBoard);\n    };\n  }, []);\n  return (\n    <BoardWrapper>\n      {board.map((row, index) => {\n        /* ROWS */\n        return (\n          <Column key={`COL-${index}`} index={index}>\n            {row.map((cell) => {\n              return (\n                <Cell\n                  key={`CELL:${cell.coords.x},${cell.coords.y}`}\n                  occupied={cell.occupied}\n                  color={\n                    cell.occupied\n                      ? connectFour.getPlayerColorByID(cell.occupied)\n                      : \"white\"\n                  }\n                />\n              );\n            })}\n          </Column>\n        );\n      })}\n    </BoardWrapper>\n  );\n};\n\nexport default Board;\n","import { useEffect, useState } from \"react\";\nimport connectFour, { events } from \"../game/app\";\nimport { Callback } from \"../game/types\";\nimport Players from \"./Players\";\nimport Board from \"./Board\";\nimport { GameWrapper } from \"./styles/wrappers\";\nconst Game = () => {\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [endState, setEndState] = useState(connectFour.getEndState());\n  const [currentPlayer, setCurrentPlayer] = useState(\n    connectFour.getCurrentPlayer()\n  );\n  //subscriptions\n  useEffect(() => {\n    const updatePlayer: Callback = (data) => {\n      setCurrentPlayer(data as { name: string; id: string });\n    };\n    const updateGameOver: Callback = (data) => {\n      setIsGameOver(data as boolean);\n    };\n    const updateGameEnd: Callback = (data) => {\n      setEndState(data as string);\n    };\n\n    // subscriptions\n    events.add(\"gameOver\", updateGameOver);\n    events.add(\"turnChange\", updatePlayer);\n    events.add(\"gameEndChange\", updateGameEnd);\n\n    //cleanup\n    return () => {\n      events.remove(\"gameOver\", updateGameOver);\n      events.remove(\"nameChange\", updatePlayer);\n      events.remove(\"gameEndChange\", updateGameEnd);\n    };\n  }, []);\n  return (\n    <GameWrapper>\n      {isGameOver ? (\n        <>\n          <Board />\n          <h2>\n            Game Over!{\"   \"}\n            {connectFour.getEndState() === \"tie\"\n              ? \"Draw!\"\n              : connectFour\n                  .getPlayerColorByID(connectFour.getEndState() as string)\n                  .toUpperCase() + \" WINS!\"}\n          </h2>\n          <Players\n            currentPlayer={currentPlayer}\n            gameOver={true}\n            winner={endState}\n          />\n        </>\n      ) : (\n        <>\n          <Board />\n          <h2>Play!</h2>\n          <Players\n            currentPlayer={currentPlayer}\n            gameOver={false}\n            winner={endState}\n          />\n        </>\n      )}\n    </GameWrapper>\n  );\n};\n\nexport default Game;\n","import { createGlobalStyle } from \"styled-components\";\n\nconst GlobalStyle = createGlobalStyle`\n\nh1,a{\n    font-family: \"Orelega One\", sans-serif;\n}\nh2{\n    text-transform: uppercase;\n    font-weight: lighter;\n    font-size: 1.2rem;\n    margin: 1rem;\n    \n}\nbutton{\n    padding: .5rem;\n    background: white;\n    border: 2px solid black;\n    font-family: \"Orelega One\", sans-serif;\n    &:hover{\n        color: #6f6f6f;\n    }\n}\n\n`;\n\nexport default GlobalStyle;\n","import \"./App.css\";\nimport Header from \"./components/Header\";\nimport Game from \"./components/game\";\nimport GlobalStyle from \"./components/styles/global\";\nfunction App() {\n  return (\n    <>\n      <GlobalStyle />\n      <Header />\n      <Game />\n    </>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}